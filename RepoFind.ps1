<#
This script enumerates repo files for data and produces a data report
using the RData class, or a search results report using the RFind class.

If an search string is provided as an arugment, a search results report is run. 
Otherwise, a data report is run

A data report reports on metadata and select paragrams and headings. A search result
report also reports on metadata for a partualar occurence.

A data report has one RData object for every file, a search results report has a
RFind object for every search result occurence.

#>



Class RData {
    [string]$Repo
    [string]$Folder
    [string]$FileName
    [string]$GitHubLink
    [string]$Date
    [string]$ArticleId
    [string]$IssueDescription
    [string]$Description
    [string]$Heading1
    [string]$Para1
    [string]$FirstH2

}

Class RFind {
    [string]$Repo
    [string]$Folder
    [string]$FileName
    [string]$ArticleId
    [string]$SearchFor
    [string]$LineNum
    [string]$Context
    [bool]$Multiple
    [string]$Heading
}

# Collections for data classes used to generate spreadsheet.
$RFdata = New-Object "System.Collections.Generic.List[RData]"
$RFresults = New-Object "System.Collections.Generic.List[RFind]"

# Determine current directory and look for config file, rfconfig.xml.
$curDir = (Get-Item -Path ".\" -Verbose).FullName
$configFile = Join-Path -Path $curDir -ChildPath "rfconfig.xml"

# Sources are the paths configured for searching in rfconfig.xml.
$sources = New-Object 'System.Collections.Generic.List[string]'

# StringBuilder for prompts
$sb = [System.Text.StringBuilder]::new()

# If script is run with an argument, a string to search for, run
# a search report, otherwise do a metadata only report.

$srchstr = $args[0]

if ($srchstr) {
    $dataOnly = $false
}
else {
    $dataOnly = $true
}

# Get values from Rfconfg.xml
if (Test-Path $configFile) {
    Try {
        #Load config app settings
        $config = [xml](get-content $configFile)

        # Get the directory where the repo is installed in
        # If blank, defaults to HOME path under /Users/.
        $rfDir = $config.configuration.startup.installdir.Value

        # Get the directory where the log files are generated.
        $logDir = $config.configuration.startup.logfiledir.Value

        # Collect all specified search paths.
        foreach ($s in $config.configuration.srchFolders.folder) {
            $sources.Add($s.Value)
        }
    }

    Catch [system.exception] {
        Write-Host $_.Exception.Message
    }
}
else {
    Write-Host "Config file not valid."
}


# Called as files are processed to get
# the value for a property in the metadata.
Function Get-PropValue {
    Param($linetxt)
    $idx = $linetxt.IndexOf("=")
    $propval = $linetxt.SubString($idx + 2)
    return $propval.TrimEnd('"')
}

# Determines the time a files was last
# checked into Github from the log files
# as generated by RepoLog.ps1
Function Get-DateFromLog {
    Param($mdFileName)
    $baseName = [System.IO.Path]::GetFileNameWithoutExtension($mdFileName)
    $logFileName = "{0}\{1}.txt" -f $logDir, $baseName    
    if (Test-Path -Path $logFileName) {
        $mdLines = Get-Content -Path $logFileName

        # Get the date from the 3rd line in the file, example:
        # Date:   Mon Feb 25 14:50:22 2019 -0800

        # I couldn't get DATETIME::TryParse to work
        $dateTxt = $mdLines[2].Substring(5).Trim()
        $dtParts = $dateTxt.Split(' ');
        $mNum = Get-MonthNumber($dtParts[1])
        $dtVal = "{0}/{1}/{2}" -f $mNum, $dtParts[2], $dtParts[4]
        return $dtVal
    }
}

# We shouldn't have to do this. DateTime.Parse is better in C#
Function Get-MonthNumber {
    Param($month)
    $mo = $month.ToLower()
    if ($mo -eq "jan") {
        $monthNum = "01"
    }
    elseif ($mo -eq "feb") {
        $monthNum = "02"
    }
    elseif ($mo -eq "mar") {
        $monthNum = "03"
    }    
    elseif ($mo -eq "apr") {
        $monthNum = "04"
    }    
    elseif ($mo -eq "may") {
        $monthNum = "05"
    }    
    elseif ($mo -eq "jun") {
        $monthNum = "06"
    }    
    elseif ($mo -eq "jul") {
        $monthNum = "07"
    }    
    elseif ($mo -eq "aug") {
        $monthNum = "08"
    }    
    elseif ($mo -eq "sep") {
        $monthNum = "09"
    }    
    elseif ($mo -eq "oct") {
        $monthNum = "10"
    }    
    elseif ($mo -eq "nov") {
        $monthNum = "11"
    }    
    elseif ($mo -eq "dec") {
        $monthNum = "12"
    }
    return $monthNum
}

# For each search path specified in RFconfig.xml...
# If there was no specification for the root repo $rfDir,
# use default $HOME or use the specified folder, such as C:\Repos
Foreach ($sf in $sources) {
    $spath = ""
    if ($rfDir -eq "") {
        $spath = Join-Path -Path $HOME -ChildPath $sf
    }
    else {
        $spath = Join-Path -Path $rfDir -ChildPath $sf      
    }
    $mdPth = "{0}\*.md" -f $spath


    $files = Get-ChildItem $mdPth -Recurse
    foreach ($file in $files) {
        if ($dataOnly) {

            # CREATE DATA REPORT (RData)

            $content = Get-Content $file
            $data = New-Object "RData"

            # Get date the file last merged to GitHub
            # If no log file, an empty string is set
            $data.Date = Get-DateFromLog $file

            $data.FileName = [System.IO.Path]::GetFileName($file)
            $fldr = [System.IO.Path]::GetDirectoryName($file)
            $dirs = $fldr.Split('\')
            $data.Repo = $dirs[2]
            $data.Folder = Split-Path -Path $fldr -Leaf
            $urlPart = "https://github.com/MyRepo/{0}/blob/master/articles/{1}/{2}" -f $data.Repo, $data.Folder, $data.FileName
            $articleURL = "=HYPERLINK(`"{0}`",`"Link`")" -f $urlPart
            $data.GitHubLink = $articleURL

            # Get the lines of the file but skip the blank ones
            $paras = New-Object System.Collections.Generic.List[string]
            foreach ($line in $content) {
                # Filter out blank lines 
                if ($line.Length -gt 1) {
                    $paras.Add($line)
                }
            }

            # Logic for determining data retrievals
            $inProps = $false
            $gotPara1 = $false
            $gotH2 = $false
            $lineNum = 0

            # For each line in the lines of content
            foreach ($line in $paras) {               
                if ($line.StartsWith("<properties")) {
                    # Inside the metadata block
                    $inProps = $true
                }
                if ($line.StartsWith("/>")) { 
                    # Outside the metadata block
                    $inProps = $false
                }
                if ($inProps) {
                    # Get values for metadata properties using the Get-PropValue
                    # function defined above. To get values for other properties
                    # add code for it here and add to the $data class.
                    if ($line.Contains("description=")) {
                        $data.Description = Get-PropValue $line
                    }
                    elseif ($line.Contains("articleId=")) {
                        $data.ArticleId = Get-PropValue $line
                    }               
                }
                else {
                    # Use various schemes to sniff data
                    if ($line.StartsWith("# ")) {
                        $data.Heading1 = $line                        
                    }
                    elseif ($line.StartsWith("<!--issueDescription-->")) {
                        # Gets the line between the issueDescription tags
                        $data.IssueDescription = $paras[$lineNum + 1]
                    }
                    elseif ($line.StartsWith("## ") -and $gotH2 -eq $false) {
                        $data.FirstH2 = $line
                        $gotH2 = $true
                    }
                    else {
                        # Gets the first non-heading paragraph
                        if ($gotPara1 -eq $false -and $line -gt $issueLn + 2) {
                            if (!$line.StartsWith("#")) {
                                $data.Para1 = $line
                                $GotPara1 = $true
                            } 
                        }  
                    } 
                }
                $lineNum++
            }
            # Add data about file to collection
            $RFdata.Add($data)
        }

        # CREATE SEARCH REPORT (RFind)

        else {
            #Track line number
            $ln = 1
            $filetxt = [System.IO.File]::ReadAllText($file)

            # If the search string ($srchstr) is in the file text, then
            # seach each line to find occurrences. Strings are
            # compared in lower case to be case-insensitive.
            if ($filetxt.ToLower().Contains($srchstr.ToString().ToLower())) {
                $content = Get-Content $file
                foreach ($line in $content) {
                    if ($line.StartsWith("<properties")) {
                        # Inside the metadata block
                        $inProps = $true
                    }
                    if ($line.StartsWith("/>")) { 
                        # Oustside the metadata block
                        $inProps = $false
                    }
                    if ($inProps) {
                        # Get values for metadata properties using the Get-PropValue
                        # function defined above. To get values for other properties
                        # add code for it here and add to the $data class. Use elseif
                        # for subsequent properties.
                        if ($line.Contains("articleId=")) {
                            $metaArticleID = Get-PropValue $line
                        }               
                    }
            
                    else {
                        # Examine each line that contains the search string 
                        if ($line.ToLower().Contains($srchstr.ToString().ToLower())) {

                            # Create data object and set properties
                            $hit = New-Object "RFind"
                            $hit.ArticleId = $metaArticleID

                            $fldr = [System.IO.Path]::GetDirectoryName($file)
                            $dirs = $fldr.Split('\')
                            $hit.Repo = $dirs[2]
                            $hit.SearchFor = $srchstr
                            $hit.FileName = [System.IO.Path]::GetFileName($file)
                            $fldr = [System.IO.Path]::GetDirectoryName($file)
                            $hit.Folder = Split-Path -Path $fldr -Leaf
                            # Multiple is true if the search string 
                            # oocurs more than once on the same line.
                            $hit.Multiple = $false

                            # Get context (usage) of occurence
                            # Include 20 chars before hit and after
                            $ix = $line.ToLower().IndexOf($srchstr.ToLower())
                            if ($ix -ge 20) {
                                $start = $ix - 20;
                                $alpha = $line.Substring($start, 20)
                            }
                            else {
                                $alpha = $line.Substring(0, $ix)
                            }
                            $slen = $srchstr.ToString().Length
                            if ($ix + $slen + 20 -ge $line.Length) {
                                $rlen = $line.Length - ($ix + $slen)
                                $omega = $line.Substring($ix + $slen, $rlen)
                            }
                            else {
                                $omega = $line.Substring($ix + $slen, 20)
                            }
                            $context = "{0}{1}{2}" -f $alpha, $srchstr, $omega
                            $hit.Context = $context

                            $hit.LineNum = $ln
                            $hit.Heading = $lasthead

                            if ($omega.Contains($srchstr)) {
                                $hit.Multiple = $true
                            }

                            if ($line.StartsWith("#")) {
                                # Gets the current heading to show
                                # the the heading the occurence is under
                                $ix = $line.ToString().IndexOf("# ")
                                $lasthead = $line.Substring($ix + 1)
                            }
                            # Add to data collection
                            $RFresults.Add($hit)
                        }
                    }
                    $ln++
                }
            }
        }
    }
}

# Generate reports
try {
    if ($RFresults.Count -gt 0) {
        $csvFile = [System.IO.Path]::Combine($curDir, "RepoFindResults.csv")
        $RFresults | Export-Csv -Path $csvFile -NoTypeInformation
        [void]$sb.AppendLine("Search results - file, line number:")
        [void]$sb.AppendLine()
        foreach ($rf in $RFresults) {
            [void]$sb.AppendLine($rf.FileName + "`t" + $rf.LineNum);
        } 
        Write-Host $sb.ToString()
        $msg = "{0} occurences found. See RepoFindResults.csv." -f $RFresults.Count
        Write-Host $msg
    }
    elseif ($RFdata.Count -gt 0) {
        $csvFile = [System.IO.Path]::Combine($curDir, "RepoFindMetadata.csv")
        $RFdata | Export-Csv -Path $csvFile -NoTypeInformation
        $msg = "{0} articles processed. See RepoFindMetadata.csv." -f $RFdata.Count
        Write-Host $msg
    }
    else {
        Write-Host "No results found."
    }
}
Catch [System.IO.IOException] {
    Write-Host "CSV file is open, please close it."
}
